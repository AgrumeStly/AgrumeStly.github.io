<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[游记] CSp2021</title>
    <url>/p/CSp2021-%E6%B8%B8%E5%AF%84/</url>
    <content><![CDATA[<p>坐标：BJ</p>
<span id="more"></span>

<h2 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h2><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h3><p>什么也没复习！！！</p>
<p>学校集训的时候在打osu没听课（逃</p>
<p>所以肯定过不了初赛！！！</p>
<h3 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h3><h4 id="S"><a href="#S" class="headerlink" title="S"></a>S</h4><p>这都是什么jb题啊，base64又是什么啊？？？</p>
<p>四毛子？？？只能说ccf你萌死了。。。</p>
<h2 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h2><h3 id="Day-n"><a href="#Day-n" class="headerlink" title="Day -n"></a>Day -n</h3><p>好吧只能说苟过去了初赛。</p>
<p>国庆集训两天，继续打osu<img src="//%E5%95%A7.tk/hanx"></p>
<p>一直在打暴力，因为教练知道我技术不行，说保有分挣2=，好吧……</p>
<p>暴力，暴力，暴力，，，</p>
<h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day -3"></a>Day -3</h3><p>因为 whk 被班主任找了……</p>
<p>身心受到极大打击。</p>
<h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h3><p>简单复习了复习基础的东西，其他什么也不会。</p>
<h3 id="Day-1-2"><a href="#Day-1-2" class="headerlink" title="Day -1"></a>Day -1</h3><p>水群，发现别人会的自己什么也不会，我直接退役吧……<img src="//%E5%95%A7.tk/youl"></p>
<p>继续练习自己的暴力能力<img src="//%E5%95%A7.tk/tuu"></p>
<p>突然通知考场被取消了，换了一个考场，有点惊讶。</p>
<h3 id="Day-1-3"><a href="#Day-1-3" class="headerlink" title="Day 1"></a>Day 1</h3><p>提前半小时到了考场，真的好冷，风也好大，为什么去年也是这样。</p>
<p>到考场后发现是在图书馆电子阅览室，两台电脑真的很近，中间也没隔板<img src="//%E5%95%A7.tk/xyx"></p>
<p>里面好大，还空着6排电脑。</p>
<p>惊讶：电脑里没虚拟机，是32位，无法用万能头，，</p>
<p>监考说本来我们都考不了了，是百般争取才可以来这里考，笑了。</p>
<p>解压密码输错两次，预计两题抱铃（铃<img src="//%E5%95%A7.tk/qq">）</p>
<p>开题顺序：A-C-B-D</p>
<h4 id="A"><a href="#A" class="headerlink" title="A"></a>A</h4><p>只会打暴力……</p>
<p>于是暴力模拟，写了大概1h，发现大样例过不去，弃……</p>
<h4 id="B"><a href="#B" class="headerlink" title="B"></a>B</h4><p>不会写（弃）</p>
<h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><p>暴力，调了1h发现大样例过得去！！！</p>
<p>后来就没看</p>
<p>然后瞟了一眼D发现并不会……</p>
<p>于是开始摸……摸……摸……</p>
<p>又去想了想B，发现回了，只是没时间了。</p>
<p>判断合法一直写挂。</p>
<p>没判 <code>(*()*)</code> 我是sb好吧……</p>
<p>总而言之啊……又是一年浪费了呢……</p>
<h3 id="Day-1-4"><a href="#Day-1-4" class="headerlink" title="Day -(-1)"></a>Day -(-1)</h3><p><img src="//%E5%95%A7.tk/youl"><img src="//%E5%95%A7.tk/youl"><img src="//%E5%95%A7.tk/youl"></p>
<p>发现还是需要在学一些算法啊，只能打暴力不行啊……</p>
<p>发现自己什么也不会……</p>
<h3 id="Day-n-1"><a href="#Day-n-1" class="headerlink" title="Day -(-n)"></a>Day -(-n)</h3><p>大家……一定要好好活下去啊……</p>
<p>希望我能好好活下去……</p>
]]></content>
      <tags>
        <tag>CSp</tag>
      </tags>
  </entry>
  <entry>
    <title>[P2206] 奶牛芭蕾</title>
    <url>/p/P2206-%E5%A5%B6%E7%89%9B%E8%8A%AD%E8%95%BE/</url>
    <content><![CDATA[<p>一道模拟好题<img src="//%E5%95%A7.tk/qiang"></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>根据各个指令模拟奶牛动作，最终求出奶牛横纵坐标最大值，并求面积。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>纯模拟即可。</p>
<p>用 $x,y$ 去存四条腿的坐标偏移</p>
<p>因为奶牛有朝向，所以我们的方向偏移数组 $d_x,d_y$ 存储转向时，应当按照顺时针顺序，这样转向时只需加一即可，因为有四个方向，所以当超过四时进行 %4 即可解决。</p>
<p>转到各个方向其实就相当于转了多少了 $90^{\circ}$。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
//aks
inline int read() &#123;
    char c=getchar(),f=0;int t=0;
    for (;c&lt;&#39;0&#39;||c&gt;&#39;9&#39;; c=getchar()) if (!(c^45)) f=1;
    for (;c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;;c=getchar()) t=(t&lt;&lt;1)+(t&lt;&lt;3)+(c^48);
    return f?-t:t;
&#125;
inline void write(int x) &#123;
    static int t[25]; int tp=0;
    if (x==0) return (void)(putchar(&#39;0&#39;)); else if (x&lt;0) putchar(&#39;-&#39;), x=-x;
    while (x) t[tp++]=x%10,x/=10;
    while (tp--) putchar(t[tp]+48);
&#125;
int n, minx, maxx, miny, maxy;//n条指令，x最小最大值，y最小最大值 
int x[] = &#123;0, 1, 1, 0&#125;; // 0FL， 1FR 
int y[] = &#123;1, 1, 0, 0&#125;; // 2RR， 3RL 
int dx[] = &#123;0, 1, 0, -1&#125;; //0上， 1右， 2下， 3左 
int dy[] = &#123;1, 0, -1, 0&#125;;
int d; // 当前方向 
int main() &#123;
    n = read();
    for (int i = 1; i &lt;= n; i++) &#123;
        char a, b, op;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; op;
        int f;
        if (a == &#39;F&#39; &amp;&amp; b == &#39;L&#39;) f = 0; // 前左腿
        if (a == &#39;F&#39; &amp;&amp; b == &#39;R&#39;) f = 1; // 前右腿
        if (a == &#39;R&#39; &amp;&amp; b == &#39;R&#39;) f = 2; // 后右腿
        if (a == &#39;R&#39; &amp;&amp; b == &#39;L&#39;) f = 3; // 后左腿
        if (op == &#39;F&#39;) x[f] += dx[d], y[f] += dy[d]; // 向前走一步 
        if (op == &#39;B&#39;) x[f] += dx[(d + 2) % 4], y[f] += dy[(d + 2) % 4]; // 顺时针 180（向后退）
        if (op == &#39;L&#39;) x[f] += dx[(d + 3) % 4], y[f] += dy[(d + 3) % 4]; // 顺时针 270（向左）
        if (op == &#39;R&#39;) x[f] += dx[(d + 1) % 4], y[f] += dy[(d + 1) % 4]; // 顺时针 90（向右）
        if (op == &#39;P&#39;) &#123;
            int x0 = x[f], y0 = y[f];
            for (int i = 0; i &lt;= 3; i++) &#123; // 将第x[i], y[i]绕x[f], y[f]顺时针旋转90度 
                x[i] -= x0, y[i] -= y0;
                swap(x[i], y[i]);
                y[i] = -y[i];
                x[i] += x0, y[i] += y0;
            &#125;
            d = (d + 1) % 4;
        &#125;
        for (int i = 0; i &lt;= 3; i++) // 枚举第 i 条腿 
            for (int j = i + 1; j &lt;= 3; j++) // 枚举第 j 条腿 
                if (x[i] == x[j] &amp;&amp; y[i] == y[j]) &#123; // 绊倒 
                    puts(&quot;-1&quot;);
                    return 0;
                &#125;
        for (int i = 0; i &lt;= 3; i++) &#123;
            minx = min(minx, x[i]);
            miny = min(miny, y[i]);
            maxx = max(maxx, x[i]);
            maxy = max(maxy, y[i]);
        &#125;
    &#125;
    cout &lt;&lt; (maxx - minx + 1) * (maxy - miny + 1) &lt;&lt; endl;
    return 0;
&#125;

</code></pre>
]]></content>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷快捷键LuoguShortcutKeys</title>
    <url>/p/%E6%B4%9B%E8%B0%B7%E5%BF%AB%E6%8D%B7%E9%94%AELuoguShortcutKeys/</url>
    <content><![CDATA[<p><a href="https://greasyfork.org/zh-CN/scripts/428234">宣传一下</a></p>
<p>当前版本：v0.5</p>
<p>一款使你的洛谷更加便捷的脚本！</p>
<span id="more"></span>

<h3 id="当前功能"><a href="#当前功能" class="headerlink" title="当前功能"></a>当前功能</h3><ul>
<li>内测版提供Ctrl+Enter发送犇犇、帖子内回复</li>
<li>全新键盘监听方式</li>
</ul>
<h3 id="预计更新"><a href="#预计更新" class="headerlink" title="预计更新"></a>预计更新</h3><ul>
<li>多种初始快捷键</li>
<li>自定义快捷键</li>
<li>更加精彩的手势</li>
<li>等等等。。。</li>
</ul>
<h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><ul>
<li>v0.1: 基础版本，发布最基础功能</li>
<li>v0.5: 增加Ctrl+Enter发送帖子回复；全新键盘监听方式；全新console</li>
</ul>
<p>顺便球球帮忙看看bug<img src="//%E5%95%A7.tk/wq"><img src="//%E5%95%A7.tk/kk"></p>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>油猴</tag>
      </tags>
  </entry>
  <entry>
    <title>树与二叉树</title>
    <url>/p/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ol>
<li>定义：由 $n(n \ge 30)$ 个节点的有限级。（$n=0$ 时成为空树）</li>
</ol>
<span id="more"></span>

<p><img src="https://i.loli.net/2021/01/31/JhXa4dvsEpimIN2.png" alt="graph.png"></p>
<ol start="2">
<li><p>结点的度：子节点的度</p>
</li>
<li><p>结点关系：  </p>
<p> A 是 BC 的父结点  </p>
<p> BC 是 A 的子结点  </p>
<p> DEF 是兄弟结点</p>
</li>
<li><p>结点层次：</p>
<p> <img src="https://i.loli.net/2021/01/31/EdQx8G7Dn3usRCi.png" alt="1-1"></p>
</li>
<li><p>树的深度：结点的最大层次数</p>
</li>
<li><p>树的宽度：每一层结点个数最大值</p>
</li>
</ol>
<hr>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>每个结点最多 2 个子结点，所以二叉树中结点的度 $\le 2$</li>
<li>每个结点最多 2 个子结点，称为左儿子和右儿子，他们有顺序的，且顺序不能任意颠倒</li>
<li>二叉树第 $i$ 层最多 $2^{i-1}$ 个结点</li>
<li>深度为 $i$ 的二叉树最多 $2^i - 1$ 个结点</li>
</ol>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><ol>
<li>所有分支节点都有两个子结点</li>
<li>所有叶结点都在同一层上</li>
<li>结点 $i$ 的左儿子 $i$ 右儿子 $i+1$</li>
<li>结点 $i$ 的父结点 $\left\lfloor \dfrac{i}{2} \right\rfloor$ </li>
</ol>
<h3 id="重复二叉树"><a href="#重复二叉树" class="headerlink" title="重复二叉树"></a>重复二叉树</h3><p>所有结点位置与满二叉树相同</p>
<h3 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right, father;</span><br><span class="line">&#125; dot[<span class="number">1005</span>];</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">left[<span class="number">1005</span>], right[<span class="number">1005</span>], father[<span class="number">1005</span>];</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(dot[i].left, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(dot[i].right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> fa)</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>遍历：从根结点出发，按照某种次序访问二叉树中的所有结点，每个结点，有且仅有一次访问</li>
<li>次序：<strong>前序遍历</strong>，<strong>中序遍历</strong>，<strong>后序遍历</strong> （dfs）层次遍历（bfs）</li>
</ol>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><ol>
<li><p>dfs 时，第 <strong>1</strong> 次搜到某个结点就输出</p>
</li>
<li><p><strong>根左右</strong>：先搜根 -&gt; 左儿子 -&gt; 右儿子</p>
</li>
<li><p>输出</p>
<p> dfs：</p>
<ol>
<li>输出 root ……….. 根</li>
<li>dfs（左子树）…. 左</li>
<li>dfs（右子树）…. 右</li>
</ol>
</li>
</ol>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ol>
<li><p>dfs 时，第 <strong>2</strong> 次搜到某个结点就输出</p>
</li>
<li><p><strong>左根右</strong>：先搜左儿子 -&gt; 根 -&gt; 右儿子</p>
</li>
<li><p>输出</p>
<p> dfs：</p>
<ol>
<li>dfs（左子树）…. 左</li>
</ol>
</li>
<li><p>输出 root ……….. 根</p>
<ol start="3">
<li>dfs（右子树）…. 右</li>
</ol>
</li>
</ol>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><ol>
<li><p>dfs 时，第 <strong>3</strong> 次搜到某个结点就输出</p>
</li>
<li><p><strong>左右根</strong>：先搜左儿子 -&gt; 右儿子 -&gt; 根</p>
</li>
<li><p>输出</p>
<p> dfs：</p>
<ol>
<li><p>dfs（左子树）…. 左</p>
</li>
<li><p>dfs（右子树）…. 右</p>
</li>
<li><p>输出 root ……….. 根</p>
</li>
</ol>
</li>
</ol>
<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>bfs 进行遍历</p>
<h3 id="前中定后，中后定前，前后定中"><a href="#前中定后，中后定前，前后定中" class="headerlink" title="前中定后，中后定前，前后定中"></a>前中定后，中后定前，<del>前后定中</del></h3><p>前：ABCDEF 中：CBAEDF 后：CBEFDA</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="LuoguP1087-NOIP2004-普及组-FBI-树"><a href="#LuoguP1087-NOIP2004-普及组-FBI-树" class="headerlink" title="[LuoguP1087][NOIP2004 普及组] FBI 树"></a>[LuoguP1087][NOIP2004 普及组] FBI 树</h4><blockquote>
<p><a href="https://www.luogu.com.cn/problem/P1087">Link</a></p>
</blockquote>
<h5 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h5><p>看样例：</p>
<p><img src="//blog.geometry37.tk/img/2021-02-01-1.PNG"></p>
<p>欲求后序遍历，模板题，套模板即可。</p>
<h5 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Problem: P1087 [NOIP2004 普及组] FBI 树</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/P1087</span></span><br><span class="line"><span class="comment">// Memory Limit: 125 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 1000 ms</span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://github.com/cpeditor/cpeditor)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maketree</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (y &gt; x) &#123;</span><br><span class="line">		<span class="built_in">maketree</span>(x, (x + y) / <span class="number">2</span>); <span class="comment">//左</span></span><br><span class="line">		<span class="built_in">maketree</span>((x + y) / <span class="number">2</span> + <span class="number">1</span>, y); <span class="comment">//右</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> B = <span class="literal">true</span>, I = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= y; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>) B = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) I = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (B == <span class="literal">true</span>) cout &lt;&lt; <span class="string">&quot;B&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (I == <span class="literal">true</span>) cout &lt;&lt; <span class="string">&quot;I&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;F&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">	<span class="built_in">maketree</span>(<span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉排序树（Binary-Sort-Tree）"><a href="#二叉排序树（Binary-Sort-Tree）" class="headerlink" title="二叉排序树（Binary Sort Tree）"></a>二叉排序树（Binary Sort Tree）</h2><p>也称二叉查找树</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol>
<li>若左子树不空，则左子树上所有结点的值 $\leq$ root</li>
<li>若右子树不空，则右子树上所有结点的值 $\geq$ root</li>
<li>左右子树也都是二叉排序树</li>
</ol>
<h3 id="建立二叉排序树"><a href="#建立二叉排序树" class="headerlink" title="建立二叉排序树"></a>建立二叉排序树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &lt; x) &#123;</span><br><span class="line">         <span class="keyword">if</span> (dot[x].left) <span class="built_in">insert</span>(dot[x].left, s);</span><br><span class="line">        <span class="keyword">else</span> dot[x].left = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; x) &#123;</span><br><span class="line">         <span class="keyword">if</span> (dot[x].right) <span class="built_in">insert</span>(dot[x].right, s);</span><br><span class="line">         <span class="keyword">else</span> dot[x].right = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="built_in">insert</span>(a[<span class="number">1</span>], a[i]); <span class="comment">//将数字 a[i] 插入结点 a[1] 下方</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>树</tag>
        <tag>图论</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>[AT4110][ABC094B] Toll Gates</title>
    <url>/p/AT4110-ABC094B-Toll-Gates/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/AT4110">AT4110</a></p>
</blockquote>
<span id="more"></span>

<h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>有一个长为 $N$ 的路 $1,2,3,…,N$，路中有 $M$ 个收费站，第 $i$ 个收费站在路的第 $a_i$ 位置，收费 $1$ 金币，你现在在 $X$ 问从 $X$ 走到 $1$ 或走到 $N$ 的最少花费</p>
<h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>用两个变量 $l, r$ 记录 $X$ 左与右的花费，最后一比较大小即可。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, m, x;</span><br><span class="line"><span class="keyword">int</span> a, l, r;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		<span class="keyword">if</span> (a &lt; x) l++;</span><br><span class="line">		<span class="keyword">else</span> r++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (l &gt; r) cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>[AT3621][ARC084B] Small Multiple</title>
    <url>/p/AT3621-ARC084B-Small-Multiple/</url>
    <content><![CDATA[<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>我们先考虑暴力，把 $K$ 的倍数枚举，每枚举一个取每位求和。  </p>
<p>这肯定超时，关键是循环取每位爆炸，那么我们不妨想，一个数的各个位数和是如何求出的。</p>
<span id="more"></span>


<p>先看个位，$1$ 的位和为 $1$，$2$ 就在 $1$ 的前提下 $+1$ 以此类推，就能求出个位位和。  </p>
<p>再看其他位，无非就是 $n$ 个 $10$ 加上若干 $1$，思考 $10$，我们可以用 $1 \times 10$ 来表示，那各位和仍为 $1$。</p>
<p>综上，我们可以整理出两种状态：$+1$ 与 $\times 10$，那么 $+1$ 是各位和 $+1$，可 $\times 10$ 各位和却不便，故可以转换为 <strong>01 bfs</strong>，如图</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/qhejrx3s.png"></p>
<p>但是我们发现还有一个问题，那就是这种方法是会超 $\sf long~long$ 的，难道我们还要用高精吗？  </p>
<p>当然不，我们发现我们欲求 $K$ 的倍数，那么我们在每次 $\times 10$ 是 $% K$ 就行了，因为这样余数不变，不影响结果。</p>
<p>讲完基本思路，讲一下如何实现。</p>
<p>我们知道 bfs 一般会用队列，那么在 01 bfs 中，我们会用到双向队列 $\rm deque$。  </p>
<p><code>#include &lt;queue&gt;</code> 与 <code>#include &lt;deque&gt;</code> 均包含 $\rm deque$，可以用任意一个库。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NR = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">bool</span> vis[NR];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> num, w;</span><br><span class="line">&#125;;</span><br><span class="line">deque&lt;node&gt; d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	d.<span class="built_in">push_front</span>(node&#123;<span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">	vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span> (!d.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> num = d.<span class="built_in">front</span>().num, w = d.<span class="built_in">front</span>().w;</span><br><span class="line">		d.<span class="built_in">pop_front</span>();</span><br><span class="line">		<span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; w &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!vis[<span class="number">10</span> * num % k]) &#123;</span><br><span class="line">			d.<span class="built_in">push_front</span>(node&#123;<span class="number">10</span> * num % k, w&#125;);</span><br><span class="line">			vis[<span class="number">10</span> * num % k] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!vis[num + <span class="number">1</span>]) &#123;</span><br><span class="line">			d.<span class="built_in">push_back</span>(node&#123;num + <span class="number">1</span>, w + <span class="number">1</span>&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; k;</span><br><span class="line">	<span class="built_in">bfs</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>bfs</tag>
        <tag>搜索</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>[AT5037] Consecutive Integers</title>
    <url>/p/AT5037-Consecutive-Integers/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有从 $1$ 到 $n$ 共 $n$ 个数，求连续整数长度为 $k$ 的个数。</p>
<span id="more"></span>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><del>让我们来认认真真推下柿子</del></p>
<p>假设 $n = 3, k = 2$，那么很容易求出值为 $2$，但这是怎么求出的？</p>
<p>不妨列一下：</p>
<p>$1\quad2\quad3$</p>
<p>那么我们可以选取 $\underline{1}\quad\underline2\quad3$ 与 $1\quad\underline2\quad\underline3$</p>
<p>我们发现可以通过枚举开头的可行位置，然后往后推 $k$ 位则必然符合，开头的可行位置个数即所求，但是因为需往后推 $k$ 位，所以开头可行位置就要 $-k$，且我们发现，从开头 $1$ 已占一位，故此时可行数又要 $+1$。</p>
<p>综上，我们推出了此题的式子：$n - k - 1$，那么这题就迎刃而解了。</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	cout &lt;&lt; n - k + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="record"><a href="#record" class="headerlink" title="record"></a>record</h3><p><a href="https://www.luogu.com.cn/record/44279468">Link</a></p>
]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[AT3931][ABC089B] Hina Arare</title>
    <url>/p/AT3931-ABC089B-Hina-Arare/</url>
    <content><![CDATA[<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>简单模拟。</p>
<span id="more"></span>

<ul>
<li>法一<br>  我们定义 4 个变量 $p,w,g,y$ ，要是出现了就赋值为 1，最后一加就是个数。</li>
<li>法二<br>  定义 4 个变量 $p,w,g,y$ 分别记录 P,W,G,Y 是否出现过，若未出现则 $ans+1$ 并标记为出现过。</li>
</ul>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><p>法一</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, p, w, g, y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line">		cin &gt;&gt; c;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;P&#x27;</span>) p = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;W&#x27;</span>) w = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;G&#x27;</span>) g = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;Y&#x27;</span>) y = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p + w + g + y == <span class="number">3</span>) cout &lt;&lt; <span class="string">&quot;Three&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Four&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>法二</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> p, w, g, y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">char</span> c;</span><br><span class="line">		cin &gt;&gt; c;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;P&#x27;</span> &amp;&amp; !p) ans++, p = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;W&#x27;</span> &amp;&amp; !w) ans++, w = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;G&#x27;</span> &amp;&amp; !g) ans++, g = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;Y&#x27;</span> &amp;&amp; !y) ans++, y = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ans == <span class="number">3</span>) cout &lt;&lt; <span class="string">&quot;Three&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Four&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>[AT4303][ABC119D] Lazy Faith</title>
    <url>/p/AT4303-ABC119D-Lazy-Faith/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.luogu.com.cn/problem/AT4303">AT4303</a></p>
</blockquote>
<h2 id="translation"><a href="#translation" class="headerlink" title="translation"></a>translation</h2><p>有 $a$ 个点 $s$，有 $b$ 个点 $t$，问从点 $x$ 出发到达至少一个 $a$ 和一个 $b$ 的最短距离是多少。</p>
<span id="more"></span>

<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>我们先举一个简单的例子，假如我们有 $2$ 个点 $s$ 分别在 $3,6$ 和 $2$ 个点 $t$ 分别在 $2,5$，$x$ 从 $4$ 出发。</p>
<p>先画一个图更好的理解</p>
<p><img src="https://i.loli.net/2020/11/15/7spJN9YZVDUqKP6.png" alt="1"></p>
<p>那么我们现在有 $4$ 种选择：</p>
<ul>
<li>选择 $s_1$ 和 $t_1$</li>
<li>选择 $s_2$ 和 $t_2$</li>
<li>选择 $s_1$ 和 $t_2$</li>
<li>选择 $s_2$ 和 $t_1$</li>
</ul>
<p>那么可以想想，还有其他的选择吗？并没有！</p>
<p>因为要选择最短的路线，如果在 $t_1$ 左边或 $s_2$ 右边还有点的话，若选择它肯定距离长，肯定要舍。</p>
<p>所以总结，只有这四种选法：</p>
<ul>
<li>左 $s$ 左 $t$</li>
<li>右 $s$ 右 $t$</li>
<li>左 $s$ 右 $t$</li>
<li>右 $s$ 左 $t$</li>
</ul>
<p>所以只要将这 $4$ 种选法都算出来，取 $\min$ 即可。</p>
<p>那如何算？</p>
<p>第一个问题：</p>
<p>如何找到在 左/右 边离 $x$ 最近的 $s/t$？</p>
<p>这里我们就要用到 <strong>二分</strong></p>
<p><del>众所周知</del> 用二分可以用 <code>lower_bound</code> 和 <code>upper_bound</code> 函数。</p>
<p>我们在这里简单介绍一下这两种函数。</p>
<ul>
<li><code>lower_bound</code><br>  此函数通过二分的原理，在 $a$ 数组中找到第一个 $\leq x$ 的数。<br>  使用：<code>lower_bound(a + 1, a + n + 1, x)</code></li>
<li><code>upper_bound</code><br>  使用方法与 <code>lower_bound</code> 类似，但是找到第一个 $\le x$ 的数。</li>
</ul>
<p>那么我们找到在 左/右 边离 $x$ 最近的 $s/t$ 就很容易了。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NR = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a, b, q;</span><br><span class="line"><span class="keyword">int</span> s[NR], t[NR];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	cin &gt;&gt; x;</span><br><span class="line">	<span class="keyword">int</span> ss = <span class="built_in">lower_bound</span>(s + <span class="number">1</span>, s + a + <span class="number">1</span>, x) - s;</span><br><span class="line">	<span class="keyword">int</span> sm = <span class="built_in">lower_bound</span>(t + <span class="number">1</span>, t + b + <span class="number">1</span>, x) - t;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">9e18</span>;</span><br><span class="line">	<span class="comment">//左社左寺</span></span><br><span class="line">	<span class="keyword">if</span> (ss &gt; <span class="number">1</span> &amp;&amp; sm &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		ans = <span class="built_in">min</span>(ans, <span class="built_in">max</span>(x - s[ss - <span class="number">1</span>], x - t[sm - <span class="number">1</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//右社右寺</span></span><br><span class="line">	<span class="keyword">if</span> (ss &lt;= a &amp;&amp; sm &lt;= b) &#123;</span><br><span class="line">		ans = <span class="built_in">min</span>(ans, <span class="built_in">max</span>(s[ss] - x, t[sm] - x));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//左社右寺</span></span><br><span class="line">	<span class="keyword">if</span> (ss &gt; <span class="number">1</span> &amp;&amp; sm &lt;= b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x - s[ss - <span class="number">1</span>] &lt;= t[sm] - x) <span class="comment">//如果左比右近或两边距离出发点相等，就先走左边</span></span><br><span class="line">			ans = <span class="built_in">min</span>(ans, (x - s[ss - <span class="number">1</span>]) * <span class="number">2</span> + (t[sm] - x));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ans = <span class="built_in">min</span>(ans, (t[sm] - x) * <span class="number">2</span> + (x - s[ss - <span class="number">1</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//右社左寺</span></span><br><span class="line">	<span class="keyword">if</span> (ss &lt;= a &amp;&amp; sm &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[ss] - x &lt;= x - t[sm - <span class="number">1</span>]) <span class="comment">//如果右比左近，就先走右边</span></span><br><span class="line">			ans = <span class="built_in">min</span>(ans, (s[ss] - x) * <span class="number">2</span> + (x - t[sm - <span class="number">1</span>]));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ans = <span class="built_in">min</span>(ans, (x - t[sm - <span class="number">1</span>]) * <span class="number">2</span> + (s[ss] - x));</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; a &gt;&gt; b &gt;&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++) cin &gt;&gt; s[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b; i++) cin &gt;&gt; t[i];</span><br><span class="line">	<span class="built_in">sort</span>(s + <span class="number">1</span>, s + a + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">sort</span>(t + <span class="number">1</span>, t + b + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> (q--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>[AT4763][ABC133B] Good Distance</title>
    <url>/p/AT4763-ABC133B-Good-Distance/</url>
    <content><![CDATA[<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><p>看到数据后暴力即可，暴力模拟，算出每个点的距离，然后判断若为整数就记录即可。</p>
<span id="more"></span>

<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NR = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> n, d, ans;</span><br><span class="line"><span class="keyword">int</span> x[NR][NR];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqr</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= d; j++)</span><br><span class="line">			cin &gt;&gt; x[i][j];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">double</span> dd = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= d; k++)</span><br><span class="line">				dd += <span class="built_in">sqr</span>(x[i][k] - x[j][k]);</span><br><span class="line">			dd = <span class="built_in">sqrt</span>(dd);</span><br><span class="line">			<span class="keyword">if</span> (dd == (<span class="keyword">int</span>)dd) ans++;</span><br><span class="line">		&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>[游记] CSp2020</title>
    <url>/p/CSp2020-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h1><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h2><p>做了个模拟（非洛谷），只有<strong>一丁点</strong>分，显然过不了</p>
<span id="more"></span>

<p><del>（盗张 i am ak f 的图）</del></p>
<p><img src="https://s1.ax1x.com/2020/10/11/0gU1nP.png" alt="0gU1nP.png"></p>
<h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>颓，颓，颓，又做了一套模拟，坚定了退役的信心。</p>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>人好多啊，风好大啊，我好冷啊。</p>
<p>走进去感觉心态挺好？</p>
<h3 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h3><p>无可否认，题目质量很好，很有区分度，成功把我区分掉了。但是阅读程序 99 行想访问出题人，好像 $\it 2.5pts$ 没了……</p>
<p>总之，考的不是很好，但应该还是可以过？（我都不信……）</p>
<h3 id="面基"><a href="#面基" class="headerlink" title="面基"></a>面基</h3><p>显然考试不重要，面基才重要，从 3 楼下来到了 102 结果没什么人，看见了书虫，结果我没认出来他他认出来我了<img src="https://cdn.luogu.com.cn/upload/pic/62250.png" alt="/fad"> 一定是我太 <del>可爱</del> 菜了，一眼就能认出来。感觉书虫好可爱啊<img src="https://cdn.luogu.com.cn/upload/pic/62224.png" alt="/qq"></p>
<p><del>rui_er 人呢，ClCN 人呢，tarjin 人呢（</del></p>
<h2 id="结束了。"><a href="#结束了。" class="headerlink" title="结束了。"></a>结束了。</h2><p>回来本来还想着可能烤得挺好，一堆答案，一切都结束了，该晋级的晋级了，该 AK 的 AK 了。我只能退役了……</p>
<p>但毕竟还有时间，希望能继续努力，实现自己的梦想吧。</p>
<h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day -(-3)"></a>Day -(-3)</h2><p>出成绩了，擦线过了（</p>
<hr>
<h1 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h1><h2 id="Day-5"><a href="#Day-5" class="headerlink" title="Day -5"></a>Day -5</h2><p>模拟赛垫底。</p>
<p>100+100+30+10</p>
<p>我直接退役好吧……</p>
<h2 id="Day-4"><a href="#Day-4" class="headerlink" title="Day -4"></a>Day -4</h2><p>简单复习了复习图论。</p>
<h2 id="Day-3-1"><a href="#Day-3-1" class="headerlink" title="Day -3"></a>Day -3</h2><p>期中考试祭，也算是进入初中后第一次大考。</p>
<p>Day1：语文，地理，数学<br>Day2：英语，生物</p>
<p>感觉地理数学都爆炸了/youl</p>
<p>竟然感觉语文还行？？？（</p>
<h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h2><h3 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h3><p>上午 pj。</p>
<p>7:00 就到了考场，在车上吃了点东西。</p>
<p>8:00 进去了</p>
<p>找到了教室，做好了，竟然坐在墙角。</p>
<p>做我前面的人来了，走近来的时候突然叫了一声：“是 TNT 吗？”</p>
<p>我吓了一跳，没见过，不认识，他是怎么认识我的，就没管。</p>
<p>8:20 把解压码发下来，输错了 5 次，不愧是我……</p>
<p>8:35 </p>
<p>监考员才说可以答题了……</p>
<p>开了看 T1，不是一眼题了，爷清洁。</p>
<p>两眼题好评，过了大样例就没管。</p>
<p>看了眼 T2，两眼题好评，一开始 sb 直接打暴力，没过大样例。</p>
<p>稍微改了改过了大样例也就没管了。</p>
<p>看 T3，这啥啊，以为是个 ds，不会，就都输出个 1 骗点分，看 T4。</p>
<p>这不就是个 dp 吗，可惜 dp 没学好，也懒得推方程，写了个贪心骗点分回来看 T3。</p>
<p>想了想是否能暴力，打了个暴力，连 Sample1 都没过，也快结束了，就把输出 1 的交了上去。</p>
<p>估分：100+100+20<del>30+20=240</del>250</p>
<p>12:35 监考员收完答题纸把我们放了出来，我立刻去问了问我前面的那位，才知道是洛谷的@超级玛丽王子，吓死我了（</p>
<p>回来洛谷测了一下，T1 挂了，T2 挂了，T3 挂了，T4 挂了</p>
<p>T1 莫名成了 60，T2 85。</p>
<p>草 nm 这个 T3 我就是傻逼好吧……</p>
<p>我分明每个程序都又运行了一下没爆啊？</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ohjlo525.png"></p>
<p>本来 30，CE 了，我退役罢……</p>
<h3 id="中午"><a href="#中午" class="headerlink" title="中午"></a>中午</h3><p>中午去吃了个海底捞，真行。</p>
<p>又跟同学讨论了一下题，一致认为，毒瘤。</p>
<h3 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h3><p>吃的有点撑，进考场时有点难受，风又大，感觉我要凉。</p>
<p>做到了座位，和 pj 一样的教室，没想到@超级玛丽王子 又来走近我。</p>
<p>我：？？？<br>他：我 pj 做你前头，tg 做你后头（</p>
<p>还挺有缘（</p>
<p>开 T1，sb 题，想拜访出题人祖母的女儿，出题人你萌死了，萌死了。</p>
<p>敲了个 20 分扔了没管看 T2。</p>
<p>竟然没怎么读懂题，花了 20 分钟读题，写了个暴力看 T3</p>
<p>天哪，不会做……（赛后得知：dp+拓扑）</p>
<p>输了个样例</p>
<p>T4 感觉可以做做试试。</p>
<p>就瞎写了写。</p>
<p>估分：20+10<del>30+0+10=40</del>60</p>
<p>出来后，看很晚了，也根本没人愿意来找我面基，就走了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自己还是基础太薄弱了，学再多的东西又有什么用呢？pj T1 都能挂。</p>
<blockquote>
<p>失败了一次，就要从跌倒的地方再爬起。</p>
</blockquote>
<p>既然已经知道自己的能力根本就不行了的话，努力吧。</p>
<p>我们 CSp2021 再见！</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>有可能我永远不可能拿到自己心中的蓝勾了，</p>
<p>从五年级就接触 OI，学了半年糊里糊涂去参加了 NOIp2018 pj，初赛那个十几分回来，当时觉得并没有什么，机会还多。</p>
<p>2019 年是 NOIp 却没了，取而代之的是 CSp，一切准备妥当时，突然有一个情况发生了：</p>
<p>CSp 与另一个比赛冲突了，</p>
<p>那个比赛是一个全国的人工智能大赛，我和另一个搭档代表 BJ 队去 TJ 参赛。</p>
<p>当时内心十分纠结，整天心态不好，去询问了教练，教练建议去参加那个比赛，可能我即使参加了 CSp 也没有能力拿奖吧。</p>
<p>可惜，心态问题，那个比赛没搞好连一等奖都没拿到，二等奖第一名。</p>
<p>又得知 pj 初赛机考水的要死，复赛 T1 一眼题，过了 T1 就二等。</p>
<p>心态立即就爆炸了，懊悔当初没去参加 CSp。</p>
<p>就又等了一年。</p>
<p>CSp2020 了，擦线过了初赛，离复赛只有三天时，才发现自己什么也不会，无比迷茫，不知自己到底会前往何方。</p>
<p>今年的比赛，暴露了我的真实水平。</p>
<p>期中考也没考好，英语下了 90。</p>
<p>明年，明年，明年。</p>
<p>恐怕，我连明天都已经没有了罢……</p>
<blockquote>
<p>upd 2020.11.08</p>
</blockquote>
]]></content>
      <tags>
        <tag>CSp</tag>
      </tags>
  </entry>
  <entry>
    <title>[P6003][USACO20JAN] Loan Repayment S</title>
    <url>/p/P6003-USACO20JAN-Loan-Repayment-S/</url>
    <content><![CDATA[<p>模拟赛第一题（</p>
<span id="more"></span>

<h3 id="9pts"><a href="#9pts" class="headerlink" title="9pts"></a>9pts</h3><p>考虑暴力。</p>
<p>枚举 $x$，对于每个 $x$，模拟 $k$ 天，判断其是否合法，找出最大的 $x$。</p>
<p>时间复杂度：$O(n^2)$</p>
<h3 id="36pts"><a href="#36pts" class="headerlink" title="36pts"></a>36pts</h3><p>考虑优化先前暴力算法。</p>
<p>我们不难发现当 $x$ 合法时，必然有合法 $x_1$，当且仅当 $x_1 &lt; x$。<br>故 $x$ 具有单调性，考虑二分答案。</p>
<p>对于 $x$，我们进行二分答案，对于每一个 $x$，我们对其进行判断是否合法。<br>其中判断合法我们每一天逐一枚举，时间复杂度 $O(k)$。若合法，我们便再去寻找更大的合法 $x$。</p>
<p>时间复杂度：$O(n \log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = (n - num) / x;</span><br><span class="line">        <span class="keyword">if</span> (y &lt; m) y = m;</span><br><span class="line">        num += y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="100pts"><a href="#100pts" class="headerlink" title="100pts"></a>100pts</h3><p>我们发现先前算法中，<code>check()</code> 函数效率为 $O(k)$，是显然超时的，我们考虑优化 <code>check()</code>。</p>
<p>对于每个 $y$，我们发现，当其中的 $x$ 固定时，存在 $z$ 使得 $y = \lfloor \dfrac{z}{x} \rfloor = \lfloor \dfrac{z + 1}{x} \rfloor = \dots = \lfloor \dfrac{z + a}{x} \rfloor$</p>
<p>故我们可以算出其中的 $a$，一次将 $a$ 个相同的 $y$ 算出。</p>
<p>我们假设当前欠了 $r$ 加仑，还有 $t$ 天的时间去还。<br>那么我们对于 $r$，每次算出 $a$，判断其是否能在 $k$ 天中还完。<br>我们知道若存在 $a$，则 $\lfloor \dfrac{z + (a - 1)}{x} \rfloor$ 依然等于 $\lfloor \dfrac{z + a}{x} \rfloor$，而 $a$ 天之后必然有 $\lfloor \dfrac{z + a}{x} \rfloor \le \lfloor \dfrac{z + a - 1}{x} \rfloor$。<br>通过计算得出 $a = \lfloor \dfrac{r}{y} - x + 1 \rfloor$<br>因为均为 <code>int</code>，故对于正整数 $a$ 直接 $a = \dfrac{r}{y} - x + 1$</p>
<p>当此时 $y &lt;= m$ 时，因为题面说明 $y = m$，故可以直接算出剩余天数能还的量。</p>
<p>容易看出，当 $r \le 0$ 或者 $t == 0$ 时，就不需要进行计算。<br>当 $t == 0$ 时，若 $r \le 0$，说明对于当前 $x$，能在规定时间内还完，故合法。</p>
<p>时间复杂度：$O(\sqrt{n} \log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">int</span> n, k, m, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = n, t = k;</span><br><span class="line">    <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; t) &#123;</span><br><span class="line">        <span class="keyword">int</span> y = r / x;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= m) r -= t * m, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="built_in">min</span>(r / y - x + <span class="number">1</span>, t);</span><br><span class="line">            r -= y * a;</span><br><span class="line">            t -= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erfen</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) num = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    ans = <span class="built_in">erfen</span>(l, r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>数学</tag>
        <tag>二分</tag>
      </tags>
  </entry>
</search>
